{"meta":{"title":"大兵的博客","subtitle":null,"description":null,"author":"Zhibin Jin","url":"https://www.sorrytime.cn","root":"/"},"pages":[{"title":"关于","date":"2019-10-11T11:45:52.747Z","updated":"2019-10-11T11:45:52.747Z","comments":false,"path":"about/index.html","permalink":"https://www.sorrytime.cn/about/index.html","excerpt":"","text":"Effective - 11 1/day 12dThinking - 800 40/day 20dspring - 30dmybatis 10dredis 10dother 10d"},{"title":"书单","date":"2019-10-06T09:44:33.132Z","updated":"2019-10-06T09:44:33.132Z","comments":false,"path":"books/index.html","permalink":"https://www.sorrytime.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-06T09:44:33.132Z","updated":"2019-10-06T09:44:33.132Z","comments":false,"path":"categories/index.html","permalink":"https://www.sorrytime.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-06T09:44:33.132Z","updated":"2019-10-06T09:44:33.132Z","comments":true,"path":"links/index.html","permalink":"https://www.sorrytime.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-06T09:44:33.132Z","updated":"2019-10-06T09:44:33.132Z","comments":false,"path":"repository/index.html","permalink":"https://www.sorrytime.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-06T09:44:33.132Z","updated":"2019-10-06T09:44:33.132Z","comments":false,"path":"tags/index.html","permalink":"https://www.sorrytime.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"gitlab安装配置","slug":"gitlab安装配置","date":"2019-11-27T06:20:21.000Z","updated":"2019-11-27T11:39:45.669Z","comments":true,"path":"2019/11/27/gitlab安装配置/","link":"","permalink":"https://www.sorrytime.cn/2019/11/27/gitlab安装配置/","excerpt":"","text":"https://www.howtoforge.com/tutorial/how-to-install-and-configure-gitlab-on-ubuntu-16-04/test","categories":[{"name":"工具","slug":"工具","permalink":"https://www.sorrytime.cn/categories/工具/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://www.sorrytime.cn/tags/gitlab/"}]},{"title":"《深入理解java虚拟机》读书笔记","slug":"《深入理解java虚拟机》读书笔记","date":"2019-11-25T15:25:13.000Z","updated":"2019-11-25T15:25:13.514Z","comments":true,"path":"2019/11/25/《深入理解java虚拟机》读书笔记/","link":"","permalink":"https://www.sorrytime.cn/2019/11/25/《深入理解java虚拟机》读书笔记/","excerpt":"","text":"","categories":[{"name":"文章分类","slug":"文章分类","permalink":"https://www.sorrytime.cn/categories/文章分类/"}],"tags":[{"name":"文章标签","slug":"文章标签","permalink":"https://www.sorrytime.cn/tags/文章标签/"}]},{"title":"《交易系统与方法》读书笔记","slug":"《交易系统与方法》读书笔记","date":"2019-11-20T14:35:19.000Z","updated":"2019-11-20T15:01:11.954Z","comments":true,"path":"2019/11/20/《交易系统与方法》读书笔记/","link":"","permalink":"https://www.sorrytime.cn/2019/11/20/《交易系统与方法》读书笔记/","excerpt":"","text":"概述低噪声有益于顺势交易，高噪声有利于均值回归交易","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.sorrytime.cn/categories/读书笔记/"}],"tags":[{"name":"《交易系统与方法》","slug":"《交易系统与方法》","permalink":"https://www.sorrytime.cn/tags/《交易系统与方法》/"}]},{"title":"《Effective Java》读书笔记","slug":"《Effective-Java》读书笔记","date":"2019-11-11T14:50:14.000Z","updated":"2019-11-29T13:26:59.784Z","comments":true,"path":"2019/11/11/《Effective-Java》读书笔记/","link":"","permalink":"https://www.sorrytime.cn/2019/11/11/《Effective-Java》读书笔记/","excerpt":"","text":"引言Java 语言支持四种类型接口（包括注释）类（包括enum）数组基本类型创建和销毁对象静态工厂方法代替构造器优点：静态工厂方法有名称不必每次使用的时候都创建一个新对象可以返回原类型的任何子类型返回的对象的类可以随着每次调用的参数不同而发生变化方法返回的对象所属的类，在编写包含静态工厂方法的类时可以不存在缺点：类如果不含有公有的或者受保护的构造器，就不能被子类化程序员很难发现静态工厂方法类的构造器具有多个参数时可考虑使用构建器建造者模式： 不直接生成想要的对象，而是让调用者使用必要的参数调用构造器（或者静态工厂），得到一个builder对象，然后客户端在builder对象上调用类似setter的方法，来设置相关参数。最后，使用者调用无参的build方法生成通常是不可变的对像。优点： 既能保证像重叠构造器模式的安全性，又能有JavaBeans模式的可读性。代码实例，静态类构造器：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Builder Patternpublic class NutritionFacts &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder&#123; //Required parameters private final int servingSize; private final int servings; //Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize,int servings)&#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val)&#123; calories = val; return this; &#125; public Builder fat(int val)&#123; fat = val; return this; &#125; public Builder sodium(int val)&#123; sodium = val; return this; &#125; public Builder carbohydrate(int val)&#123; carbohydrate = val; return this; &#125; public NutritionFacts build()&#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder)&#123; servings = builder.servings; servingSize = builder.servingSize; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; &#125;&#125;//Builder Testpublic static void Test_NutritionFacts()&#123; NutritionFacts cocaCola = new NutritionFacts.Builder(240,8).calories(100).sodium(35) .carbohydrate(27).build(); System.out.println(cocaCola.GetCalories()); System.out.println(cocaCola.GetServings()); System.out.println(cocaCola.GetServingSize());&#125;;代码实例，使用类层次根部的抽象类表示各式各样的pizza（类层次结构的builder模式）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//Builder pattern for class hierarchiespublic class Pizza &#123; public enum Topping&#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125; final Set&lt;Topping&gt; toppings; // 泛型类，带有一个递归类型参数，和抽象的self方法一样， // 允许在子类适当地地方进行方法链接，不需要转换类型 abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt;&#123; //creating one empty set EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping)&#123; toppings.add(Objects.requireNonNull(topping)); return self(); &#125; abstract Pizza build(); // Subclasses must overrite this method to return &quot;this&quot; // 针对Java缺乏self类型的解决方案 protected abstract T self(); &#125; Pizza(Builder&lt;?&gt; builder)&#123; toppings = builder.toppings.clone(); // &#125;&#125;//subclasspublic class NyPizza extends Pizza &#123; public enum Size &#123; SMALL, MEDIUM, LARGE &#125; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt;&#123; private final Size size; public Builder(Size size)&#123; this.size = Objects.requireNonNull(size); &#125; @Override public NyPizza build()&#123; return new NyPizza(this); &#125; @Override protected Builder self()&#123; return this; &#125; &#125; private NyPizza(Builder builder)&#123; super(builder); size = builder.size; &#125; public Size GetSize()&#123; return this.size; &#125;&#125;//subclssspublic class Calzone extends Pizza&#123; private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private boolean sauceInside = false; //Default public Builder sauceInside()&#123; sauceInside = true; return this; &#125; @Override public Calzone build()&#123; return new Calzone(this); &#125; @Override protected Builder self()&#123; return this; &#125; &#125; private Calzone(Builder builder)&#123; super(builder); sauceInside = builder.sauceInside; &#125; public boolean GetSauce()&#123; return this.sauceInside; &#125;&#125;//Builder Testpublic static void Test_Pizza()&#123; NyPizza pizza = new NyPizza.Builder(NyPizza.Size.SMALL) .addTopping(Pizza.Topping.SAUSAGE).addTopping(Pizza.Topping.ONION).build(); Calzone calzone = new Calzone.Builder() .addTopping(Pizza.Topping.HAM).sauceInside().build(); System.out.println(pizza.GetSize()); System.out.println(calzone.GetSauce()); &#125;用私有构造器或者枚举类型强化Singleton属性单例实现的三种方法：final类型的公有静态成员1234567//Singleton with public fieldpublic class Elvis&#123; public static final Evis INSTANCE = new Elvis(); private Elvis()&#123; ... &#125; public void leaveTheBuilding() &#123; ... &#125;&#125;缺点：特权用户可通过AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。优点：1. 简单；2. 清晰的向用户表达出该类是单例模式。公有静态成员工厂12345678//Singleton with static factorypublic class Elvis &#123; Private static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; ... &#125; public static Elvis getInstance() &#123; return INSTANCE; &#125; public void leaveTheBuilding() &#123; ... &#125;&#125;缺点：1.实现稍复杂；2.具有同上相同风险；优点：1.灵活，不改变接口的情况下，修改器内部实现；2.实现泛型单例工厂；3.通过方法引用提供实例。（以上2种方法实现，排除使用第二种方法优点的情况下，优先使用方法1）声明单个元素的枚举类型123456// Enum singleton - the preferred approachpublic enum Elvis &#123; INSTANCE; public void leaveTheBuilding()&#123; ...&#125;&#125;缺点：若单例必需扩展一个超类，而不是Enum，则不宜使用该方法；优点：1.更加简洁，无偿提供序列化机制；2.防止任何形式的多次序列化攻击；（单元素的枚举是实现常用单例模式的最佳方法）优先考虑依赖注入来引用底层资源及时消除过期的对象引用，防止内存泄漏Stack类易发生内存泄漏需要主动销毁引用，通过stack[size] = null缓存易发生内存泄漏用WeakHashMap代表缓存，当缓存过期会被自动消除；或者使用后台线程定期清理。监听器和其他回调易发生内存泄漏回调注册后需要显式的取消注册最佳方法是保存对回调的弱引用（weak reference）try-with-resources 优先于try-finally用于关闭资源要使用try-with-resources这个构造资源必需先实现AutoCloseable接口1234567//try-with-resources -the best way to close resources.static String firstLineOfFile(String path) throws IOException&#123; try(BufferedReader br = new BufferedReader( new FileReader(path)))&#123; return br.readLine();&#125; &#125;对于所有对象都通用的方法覆盖equals时的通用约定对称的、传递的和一致的实现高质量equals方法诀窍使用==操作符检查”参数是否为这个对象的引用”，如果是返回true；使用instanceof操作符检查 “参数是否为正确的类型，不是返回false”；把参数转换成正确的类型；对于该类中的每个”关键”域，检查参数中的域是否与该对象中对应的域相匹配，如果匹配怎返回true。实例：123456789101112131415161718192021222324//Class with a typical equals methodpublic final class PhoneNumber &#123; private final short areaCode, prefix,lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) &#123; this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;); this.prefix = rangeCheck(prefix, 999, &quot;prefix&quot;); this.lineNum = rangeCheck(lineNum, 999, &quot;line num&quot;); &#125; private static short rangeCheck(int val, int max, String arg)&#123; if(val &lt; 0 || val &gt; max)&#123; throw new IllegalArgumentException(arg + &quot;:&quot; + val); return (short)val; &#125; @Override public boolean equals(Object o)&#123; if(o == this) return true; if(!(o instanceof PhoneNumber)) return false; PhoneNumber pn = (PhoneNumber)o; return pn.lineNum == lineNum &amp;&amp; pn.prefix ==prefix &amp;&amp; pn.areacode == areaCode; &#125;&#125;警告：覆盖equals方法时总要覆盖hashCode；不要企图让equals方法过去智能；不要将equals声明中的Object类替换为其他的类型。Auto Value框架提供了很好的替代方法，可以不必手工编写equals和hashcode方法始终要覆盖toString谨慎覆盖clone方法对象拷贝应选择提供一个拷贝构造器或者拷贝工厂1234//copy constructorpublic Yum（Yum yum）&#123; ... &#125;//Copy factorypublic static Yum newInstance（Yum yum）&#123; ... &#125;Comparable接口实现每档实现一个对排序敏感的类时，都应该让这个类实现Comparable接口。类和接口使类和成员的可访问性最小化成员的四种可访问性私有的（private），显示声明；包级私有（package-private）默认；受保护的（protected），显示声明；公有的（public）任何地方都可以访问成员。让类具有公有的静态final数组域，后者返回这种域的访问方法，是错误的（客户端能够修改数组中的内容）解决方法：使公有数组编程私有的，并增加一个公有的不可变列表：123private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;public static final List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));使数组变成私有的，并添加一个公有方法，返回私有数组的一个拷贝：1234private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;public static final Thing[] values()&#123; return PRIVATE_VALUES.clone();&#125;复合优先于继承复合（composition）不扩展现有的类，而是在新的类中增加一个私有域，现有类变成新类的一个组件使用。转发（forwarding）新类中的每个实例方法调用被包含的现有类实例中对应的方法，并返回它的结果，新类中的方法被成为转发方法。实例（新类和转发类）：1234567891011121314151617181920212223242526272829303132333435363738394041//Wrapper class - uses composition in place of inheritancepublic class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123; private int addCount = 0; public InstrumentedSet(Set&lt;E&gt; s)&#123; super(s); &#125; @Override public boolean add(E e)&#123; addCount++; return super.add(e); &#125; @Override public boolean addAll(Collection&lt;? extends E&gt; c)&#123; addCount += c.size(); return super.addAll(c); &#125; public int getAddCount()&#123; return addCount; &#125;&#125;//Reusable forwarding class public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123; private final Set&lt;E&gt; s; public ForwardingSet(Set&lt;E&gt; s)&#123;this.s = s;&#125; public void clear() &#123;s.clear();&#125; public boolean contains(Object o)&#123;return s.contains(o);&#125; public boolean isEmpty() &#123;return s.isEmpty();&#125; public int size() &#123;return s.size()&#125; public Iterator&lt;E&gt; iterator() &#123;return s.iterator();&#125; public boolean add(E e) &#123;return s.add(e);&#125; public boolean remove(Object o) &#123;return s.remove(o);&#125; public boolean containsAll(Collection&lt;?&gt; c)&#123; return s.containsAll(c);&#125; public boolean addAll(Collection&lt;? extends E&gt; c)&#123; return s.addAll(c);&#125; public removeAll(Collection&lt;?&gt; c)&#123;return s.removeAll(c);&#125; public retainAll(Collection&lt;?&gt; c)&#123;return s.retainAll(c);&#125; public Object[] toArray() &#123;return s.toArray();&#125; public &lt;T&gt; T[] toArray(T[] a) &#123;return s.toArray(a);&#125; @Override public boolean equeals(Object o)&#123;return s.equals(o);&#125; @Override public int hashCode() &#123;return s.hashCode();&#125; @Override public String toString() &#123;return s.toString();&#125; &#125;设计继承类则必需提供详细文档说明，或不使用继承为继承而设计的父类，唯一的方法是编写三个及以上的子类父类需要遵循的一些约束（消除类中可覆盖方法的自用特性）构造器不可调用可被覆盖的方法clone和readObject都不能调用可覆盖的方法把不需要子类化的类要禁止子类化禁止类子类化的两种方法方法一 把这个类声明为final方法二 把所有构造器都变成私有的，增加一些公有的静态工厂来代替构造器接口优于抽象类接口是定义mixin（混合类型）的理想选择，抽象类不能被用于定义mixin抽象骨架实现类接口负责定义类型，及一些缺省方法，骨架实现类负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作。这就是模版方法模式。如果基本方法和缺省方法覆盖了接口，就不需要骨架实现类了，否则就要编写一个类，声明实现接口，并实现所有剩下的接口方法。该类中可以包含任何非公有的域，以及适合该任务的方法。实例Map.Entry接口：12345678910111213141516171819202122232425262728293031//Skeletal implementation classpublic abstract class AbstractMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;&#123; // Entries in a modifiable map must override this method @Override public V setValue(V value)&#123; throw new UnsupportedOperationException(); &#125; // Implements the general contract of Map.Entry.equals @Override public boolean equals(Object o)&#123; if (o == this)&#123; return true; &#125; if(!(o instanceof Map.Entry))&#123; return false; &#125; Map.Entry&lt;?,?&gt; e = (Map.Entry) o; return Objects.equals(e.getKey(), getKey()) &amp;&amp; Objects.equals(e.getValue(), getValue()); &#125; //Implements the general contract of Map.Entry.hashCode @Override public int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; @Override public String toString() &#123; return getKey() + &quot;=&quot; + getValue(); &#125;&#125;//该骨架实现不能在Map.Entry接口中实现，也不能作为子接口，**因为不允许缺省方法覆盖Object方法** (Object方法必须被显示覆盖)，如equals、hashCode和toString泛型尽量消除非受检警告如果无法消除警告，同时可以证明引起警告的代码是类型安全的，才可以用一个@SuppressWarnings(“unchecked”)注解来禁止这条警告。应该在尽可能小的范围是用SuppressWarnings注解列表优于数组数组在运行时检查和强化元素类型；泛型则在编译时强化类型信息，在运行时通过擦除丢失类型信息。创建具体类型化的泛型数组非法（错误提示或警告），创建无限制通配类型的数组合法泛型会擦除具体类型，导致不同类型的数组互相可转换，违反类型转换规则。比如string类型泛型数组的元素插入Integer类型泛型数组中。数组和泛型如果放在一起使用得到警告，可尝试用列表代替数组（list）泛型通配符的PECS（producer-extends，consumer-super）原则类型安全的异构容器（实例Favorites）12345678910111213//Typesafe heterogeneous container pattern - implementationpublic class Favorites &#123; private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance)&#123; favorites.put(Objects.requeireNonNull(type),instance); &#125; public &lt;T&gt; T getFavorite(Class&lt;T&gt; type)&#123; return type.cast(favorites.get(type)); &#125;&#125;//每个键都有一个不同的参数化类型，比如一个可以是Class&lt;String&gt;,下一个可以是Class&lt;Integer&gt;,这就是异构。枚举和注解用enum代替int常量int枚举模式不具有类型安全性，enum模式改善了这种缺陷；enum枚举允许添加任意的方法和域，并实现任意的接口；实例：123456789101112131415161718192021222324252627282930313233343536//Enum type with data and behaviorpublic enum Planet &#123; MERCURY(3.302e+23, 2.439e6), VENUS (4.869e+24, 6.052e6), EARTH (5.975e+24, 6.378e6), MARS (6.419e+23), 3.393e6); private final double mass; // In kilograms private final double radius; // In meters private final double surfacegravity; // In m/s^2 // Universal gravitational constant in m^3 / kg s^2 private static final double G = 6.67300E-11; // Constructor Planet(double mass, double radius)&#123; this.mass = mass; this.radius = radius; surfaceGravity = G * mass / (radius * radius); &#125; public double mass() &#123;return mass;&#125; public double radius() &#123;return radius;&#125; public double surfaceGravity() &#123;return surfaceGravity;&#125; public double surfaceWeight(double mass)&#123; return mass * surfaceGravity; // F = ma &#125;&#125;//每个枚举变量括号后面的数值就是传递给构造器的参数public class WeightTable &#123; public static void main(String[] args)&#123; doulbe earthWeight = Double.parseDouble(args[0]); double mass = earthWeight / Planet.EARTH.surfaceGravity(); for(Planet p: Planet.values())&#123; System.out.printf(&quot;Weight on %s is %f%n&quot;, p, p.surfaceWeight(mass)); &#125; &#125;&#125;特定于枚举常量的方法实现在枚举类型中声明一个抽象的apply方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象apply方法实例：123456789//Enum type with constant-specific method implementationspublic enum Operation&#123; PLUS &#123;public double apply(double x, double y) &#123;return x + y;&#125;&#125;, MINUS &#123;public double apply(double x, double y) &#123;return x - y;&#125;&#125;, TIMES &#123;public double apply(double x, double y)&#123;return x * y;&#125;&#125;, DIVIDE &#123;public double apply(double x, double y)&#123;return x / y;&#125;&#125;; public abstract double apply(double x, double y);&#125;枚举常量后可跟相应的符号，并通过覆盖toString方法输出常量对应的符号，如果这样，需要编写一个由常量符号转成常量本身的方法，类似于valueOf策略枚举实现 每当添加一个枚举常量时，就强制选择一种加班报酬的策略，可通过策略枚举实现实例：12345678910111213141516171819202122232425262728293031323334353637//The strategy enum patternenum PayrollDay &#123; MONDAY, TUESDATY, WEDNESDAY, FRIDAY, SATURDAY(PayType.WEEKDAY),SUNDAY(PayType.WEEKEND); private final PayType payType; PayrollDay(PayType payType)&#123;this.payType = payType;&#125; PayrollDay() &#123;this(PayType.WEEKDAY);&#125; //Default int pay(int minutesWorked, int payRate)&#123; return payType.pay(minutesWorked, payRate); &#125; //The strategy enum type private enum PayType&#123; WEEKDAY &#123; int overtimePay(int minsWorked, int payRate)&#123; return minsWorked &lt;= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate /2; &#125; &#125;, WEEKEND&#123; int overtimePay(int minsWorked, int payRate)&#123; return minsWorked * payRate / 2; &#125; &#125;; abstract int overtimePay(int mins, int paRate); private static final int MINS_PER_SHIFT = 8 * 60; int pay(int minsWorked, int payRate) &#123; int basePay = minsWorked * payRate; return basePay + overtimePay(minsWorked, payRate); &#125; &#125;&#125;枚举索引数组使用EnumMap标记接口和标记注解Lambda和StreamLambda优先于匿名类注意：Lambda没有名称和文档，一行是理想的，三行是最大极限。Lambda限于函数接口（包括构造函数）不适合抽象类的实例，抽象类实例可通过匿名类完成Lambda中，关键字this是指外围实例（匿名类中，关键字this是指匿名类实例）Lambda是表示小函数对象的最佳方式方法引用和Lambda哪个简洁用哪个stream 谨慎使用为了正确使用stream，必需了解收集器，重要的收集器工厂是toList、toSet、toMap、groupingBy和joining方法保护性拷贝对于参数类型可以被不可信任方子类化的参数，不要使用clone方法进行保护性拷贝，应该使用new实例：12345678910111213141516171819202122//defensive copy classpublic final class Period&#123; private final Date start; private final Date end; //defensive copies of parameters public Period(Date start, Date end)&#123; this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); if(this.start.compareTo(this.end)&gt;0)&#123; throw new IllegalArgumentException(this.start + &quot; after &quot; + this.end); &#125; &#125; //defensive copies of internal fields public Date start()&#123; return new Date(start.getTime()); &#125; public Date end()&#123; return new Date(end.getTime()); &#125;&#125;慎用重载方法使用重载方法安全保守的策略是，永远不要导出两个具有相同参数数目的重载方法返回零长度的数组或者集合，而不是nullJavadoc 生成注释文档通用编程for-each循环的优势与劣势优势：避免混乱和出错劣势：不能用于集合或数组的修改编辑，推荐仅在遍历时使用。StringBuilder代替String来存储构造字符串，可提高性能不要使用字符串连接操作符来合并多个字符串，除非对性能无要求，否则应该使用StringBuilder的append方法。尽可能使用接口引用对象接口优于反射机制异常最常见可重用异常异常使用场合IllegalArgumentException非null的参数值不正确IllegalStateException不适合方法调用的对象对象状态NullPointerException在禁止使用null的情况下参数值为nullIndexOutOfBoundsException下标参数值越界ConcurrenModificationExcetion在禁止并发修改的情况，检测到对象的并发修改UnsupportedOperationException对象不支持用户请求的方法方法调用的失败原子性失败的方法调用应该使对象保持在被调用之前的状态，具有该属性的方法被称为具有失败原子性并发Java语言规范保证读或者写一个变量是院子的（atomic），除非这个变量是long或者double类型尽量将同步区域内的工作量限制到最少executor task和stream 优先于线程如果编写的是小程序，或者是轻量负载的服务器，使用Executors.newCachedThreadPool是不错的选择如果服务器负载重，最好使用Executors.newFixedThreadPool，它提供了一个包含固定线程数目的线程池。最大限度的控制，可以使用ThreadPoolExecutorjava.util.concurrent 中高级工具分为三类Executor Framework并发集合（Concurrent Collection）同步器（Synchronizer）序列化尽可能使用第三方序列化方法代替Java序列化方法Jsonprotobuf","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.sorrytime.cn/categories/读书笔记/"}],"tags":[{"name":"《Effective Java》","slug":"《Effective-Java》","permalink":"https://www.sorrytime.cn/tags/《Effective-Java》/"}]},{"title":"ipfs 跨域配置","slug":"ipfs-跨域配置","date":"2019-11-02T05:50:14.000Z","updated":"2019-11-02T05:51:47.116Z","comments":true,"path":"2019/11/02/ipfs-跨域配置/","link":"","permalink":"https://www.sorrytime.cn/2019/11/02/ipfs-跨域配置/","excerpt":"","text":"IPFS启动后的跨域配置12$ ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin &apos;[&quot;http://www.ipfslink.net:9000&quot;, &quot;http://127.0.0.1:5001&quot;, &quot;https://webui.ipfs.io&quot;]&apos;$ ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods &apos;[&quot;PUT&quot;, &quot;GET&quot;, &quot;POST&quot;]&apos;","categories":[{"name":"IPFS","slug":"IPFS","permalink":"https://www.sorrytime.cn/categories/IPFS/"}],"tags":[{"name":"跨域配置","slug":"跨域配置","permalink":"https://www.sorrytime.cn/tags/跨域配置/"}]},{"title":"IPFS 播放器安装","slug":"IPFS-播放器安装","date":"2019-11-01T02:00:29.000Z","updated":"2019-11-02T05:49:02.095Z","comments":true,"path":"2019/11/01/IPFS-播放器安装/","link":"","permalink":"https://www.sorrytime.cn/2019/11/01/IPFS-播放器安装/","excerpt":"","text":"安装平台：Ubuntu, 播放器地址：https://github.com/download13/ipfstube申请SSL证书安装Nginxsudo apt-get -y install nginx安装 letsencryptsudo apt-get -y install letsencrypt安装 Docker、Docker ComposeDocker安装curl -sSL https://get.docker.com/ | shservice docker startDocker Compose安装12curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose端口检查为防止80端口冲突，导致安装失败，先卸载掉之前的Nginx。apt-get -y remove nginx1234#找到80后的LISTEN xx/yy，xx就是进程号netstat -lnp|grep 80#杀掉xx进程kill -9 xx安装 ipfstue12345apt-get -y install gitgit clone https://github.com/download13/ipfstube.gitcd ipfstube#编辑nginx.conf文件nano nginx.confserver_name和ssl证书后面的域名改成你的运行docker-compose up -d修改docker端口映射https://blog.csdn.net/mazhen1991/article/details/85674209","categories":[{"name":"IPFS","slug":"IPFS","permalink":"https://www.sorrytime.cn/categories/IPFS/"}],"tags":[{"name":"播放器","slug":"播放器","permalink":"https://www.sorrytime.cn/tags/播放器/"}]},{"title":"git 新建远程仓库并初始化","slug":"git-新建远程仓库并初始化","date":"2019-10-21T12:12:36.000Z","updated":"2019-10-21T12:42:36.292Z","comments":true,"path":"2019/10/21/git-新建远程仓库并初始化/","link":"","permalink":"https://www.sorrytime.cn/2019/10/21/git-新建远程仓库并初始化/","excerpt":"","text":"新建项目git仓库创建git仓库名称和路径，假定是/home/git/repro/xxx.git，在/home/git目录下输入命令：12$ mkdir repro$ chown git:git repro/ //修改repro目录归属初始化仓库123$ cd repo$ git init --bare xxx.git //初始化远程空仓库，该仓库不允许直接进行git命令操作$ chown -R git:git xxx.git //仓库所属用户改为git克隆仓库1$ git clone git@ip:/home/git/repro/xxx.git通过克隆已有仓库创建新的裸仓库1$ git clone --bare xxxproject yyyproject.git","categories":[{"name":"工具","slug":"工具","permalink":"https://www.sorrytime.cn/categories/工具/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"https://www.sorrytime.cn/tags/GIT/"}]},{"title":"http跨域时的options请求详解及解决Go Rest Api 服务跨域问题","slug":"http跨域时的options请求详解及解决Go-Rest-Api-服务跨域问题","date":"2019-10-21T09:17:15.000Z","updated":"2019-11-02T05:49:02.096Z","comments":true,"path":"2019/10/21/http跨域时的options请求详解及解决Go-Rest-Api-服务跨域问题/","link":"","permalink":"https://www.sorrytime.cn/2019/10/21/http跨域时的options请求详解及解决Go-Rest-Api-服务跨域问题/","excerpt":"","text":"什么是options请求无论后端还是前端，开发过程中多多少少都会碰到跨域问题，跨域问题中多数会遇到options请求问题。 在正式的跨域之前，某些条件下浏览器会根据需要发起一次预检，这就是options请求，用来让服务端返回允许的方法。跨域请求类型浏览器将跨域请求分为两类，简单请求和非简单请求，简单请求时浏览器不会进行预检，非简单请求时会进行预检。简单请求同时满足以下三个条件的属于简单请求： 1. 请求方式只能是： GET、POST、HEAD 2. HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID 3. Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求，浏览器直接请求，在请求头信息中，增减origin字段，来说明本次请求来源（协议+域名+端口）。 服务器根据这个值来决定是否同意请求，服务器返回的响应则会多几个头信息端。非简单请求是对服务器有特殊要求的请求，比如请求方式是PUT/DELETE,或者Content-Type字段类型是application/json. 都会在正式通信之前，通过增加一次HTTP请求预检。向服务器询问当前网页所在域名是否在服务器许可名单， 服务器允许后方可进行后续正式请求，否则报错。这时需要后端实现拦截器排除Options请求。Golang Restful 跨域使用Go-Swagger生成的RESTFul后端框架中碰到了跨域Options预检请求问题，通过后端实现拦截器来过滤Options请求。 具体实现如下： configure_XXX.go文件中实现以下1234567891011121314151617 func setupGlobalMiddleware(handler http.Handler) http.Handler &#123; return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) &#123; //cros w.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) w.Header().Set(&quot;Access-Control-Allow-Headers&quot;,&quot;Content-Type,AccessToken,X-CSRF-Token,Authorization,Token&quot;) w.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, OPTIONS, PUT, DELETE&quot;) w.Header().Set(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;) w.Header().Set(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;) method := r.Method if method == &quot;OPTIONS&quot; &#123; w.WriteHeader(http.StatusNoContent) return &#125; //end handler.ServeHTTP(w, r) &#125;)&#125;","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://www.sorrytime.cn/categories/Web开发/"}],"tags":[{"name":"Golang跨域问题","slug":"Golang跨域问题","permalink":"https://www.sorrytime.cn/tags/Golang跨域问题/"}]},{"title":"IPFS.io 访问设置","slug":"IPFS-io-访问设置","date":"2019-10-16T01:00:21.000Z","updated":"2019-10-18T11:01:30.139Z","comments":true,"path":"2019/10/16/IPFS-io-访问设置/","link":"","permalink":"https://www.sorrytime.cn/2019/10/16/IPFS-io-访问设置/","excerpt":"","text":"查找主机hosts文件Windows hosts系统文件目录hosts文件一般放在C:\\Windows\\System32\\drivers\\etc，如果没有请全盘搜索。修改Hosts文件windows系统hosts文件修改末尾加入以下两行12209.94.78.78 ipfs.io209.94.90.1 ipfs.io","categories":[{"name":"IPFS","slug":"IPFS","permalink":"https://www.sorrytime.cn/categories/IPFS/"}],"tags":[{"name":"ipfs.io访问设置","slug":"ipfs-io访问设置","permalink":"https://www.sorrytime.cn/tags/ipfs-io访问设置/"}]},{"title":".MD常用语法","slug":"MD常用语法","date":"2019-10-11T08:54:40.000Z","updated":"2019-10-21T12:10:51.846Z","comments":true,"path":"2019/10/11/MD常用语法/","link":"","permalink":"https://www.sorrytime.cn/2019/10/11/MD常用语法/","excerpt":"","text":".md(markdown)是一种快速标记、快速排版语言，目前很多项目的readme都是使用.md文件编写。常用符号 ‘# * - . &gt;’常用符号开头后的空格要注意，空格用于分割标记符合内容。标题符号‘#’正常标签1234# 一级标题 ## 二级标题 ### 三级标题#### 四级标题标签闭合1234# 一级标题 ### 二级标题 ##### 三级标题 ####### 四级标题 ####列表符号‘+ 1.’无序列表123+ a + b + cabc有序列表1231. a2. b3. cabc引用说明区块 &gt;对内容做一些说明或者引用他人等。正常形式12&gt; 引用内容&gt; 说明内容效果：引用内容说明内容嵌套形式123456&gt; 1级引用&gt;&gt; 2级引用&gt;&gt;&gt; 3级引用&gt;&gt;&gt;&gt; 4级引用&gt;&gt;&gt;&gt;&gt; 5级引用&gt;&gt;&gt;&gt;&gt;&gt; 6级引用效果：1级引用2级引用3级引用4级引用5级引用6级引用代码块 `单行代码块`单行代码块`效果：单行代码块多行代码块```多行代码多行代码```效果：12多行代码块多行代码块链接行内式链接文字放在[]中，链接地址放在()中，链接可带title属性，链接地址后空一格，然后把title用引号引起来。12[myblog](https://blog.bitqts.com &quot;我的博客&quot;),是一个人原创博客,用于记录和分享学习工作中的问题及心得。效果：myblog, 是一个人原创博客,用于记录和分享学习工作中的问题及心得。参数式链接文字放在[]中，链接地址放在:后，链接地址后空一格，然后用引号引起来，使用时直接[]引用链接文字。123[myblog]是一个人原创博客,用于记录和分享学习工作中的问题及心得。[myblog]: https://blog.bitqts.com &quot;我的博客&quot;效果：myblog是一个人原创博客,用于记录和分享学习工作中的问题及心得。图片引用行内式[]前要加上!，图片名放在[]中，图片地址和title放在随后的()中，title前空一格用引号引起来。1![mylogo](images/me.jpeg &quot;我的logo&quot;)参数式图片名放在[]中，图片地址放在:后，title前空一格用引号引起来,引用图片的时候在[]前加上!12![mylogo][mylogo]: images/me.jpeg &quot;我的logo&quot;分割线分割线由* - _（星号，减号，底线）3个符号中的至少3个重复的符号表示。123456789---- - -------**** * *******____ _ _______特殊处理字体一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗1234*myblog* **myblog**_myblog_ __myblog__效果：myblogmyblogmyblogmyblog转义123456\\\\\\*\\+\\-\\`\\_删除线1~~删除~~效果：删除表格设置12345|456|456|456||:---|:---:|---:||def|def|def||def|def|def||def|def|def|效果：456456456defdefdefdefdefdefdefdefdef","categories":[{"name":"工具","slug":"工具","permalink":"https://www.sorrytime.cn/categories/工具/"}],"tags":[{"name":".MD语法","slug":"MD语法","permalink":"https://www.sorrytime.cn/tags/MD语法/"}]},{"title":"《Thinking In Java》读书笔记","slug":"《Thinking-In-Java》读书笔记","date":"2019-10-11T06:31:13.000Z","updated":"2019-10-11T11:45:52.746Z","comments":true,"path":"2019/10/11/《Thinking-In-Java》读书笔记/","link":"","permalink":"https://www.sorrytime.cn/2019/10/11/《Thinking-In-Java》读书笔记/","excerpt":"","text":"","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.sorrytime.cn/categories/读书笔记/"}],"tags":[{"name":"《Thinking In Java》","slug":"《Thinking-In-Java》","permalink":"https://www.sorrytime.cn/tags/《Thinking-In-Java》/"}]},{"title":"数据结构-四叉树","slug":"数据结构-四叉树","date":"2019-10-07T07:54:51.000Z","updated":"2019-10-11T11:45:52.747Z","comments":true,"path":"2019/10/07/数据结构-四叉树/","link":"","permalink":"https://www.sorrytime.cn/2019/10/07/数据结构-四叉树/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.sorrytime.cn/categories/数据结构/"}],"tags":[{"name":"四叉树","slug":"四叉树","permalink":"https://www.sorrytime.cn/tags/四叉树/"}]},{"title":"数据结构-单链表","slug":"数据结构-单链表","date":"2019-10-06T12:41:50.000Z","updated":"2019-11-02T05:49:02.096Z","comments":true,"path":"2019/10/06/数据结构-单链表/","link":"","permalink":"https://www.sorrytime.cn/2019/10/06/数据结构-单链表/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.sorrytime.cn/categories/数据结构/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://www.sorrytime.cn/tags/单链表/"}]},{"title":"Hexo 常用命令","slug":"hexo","date":"2018-10-06T12:41:50.000Z","updated":"2019-10-11T11:45:52.746Z","comments":true,"path":"2018/10/06/hexo/","link":"","permalink":"https://www.sorrytime.cn/2018/10/06/hexo/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/https://blog.cofess.com/2017/11/01/hexo-blog-theme-pure-usage-description.html","categories":[{"name":"工具","slug":"工具","permalink":"https://www.sorrytime.cn/categories/工具/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.sorrytime.cn/tags/Hexo/"}]},{"title":"图片测试","slug":"post-name","date":"2017-10-06T12:41:50.000Z","updated":"2019-10-11T11:45:52.746Z","comments":true,"path":"2017/10/06/post-name/","link":"","permalink":"https://www.sorrytime.cn/2017/10/06/post-name/","excerpt":"","text":"test","categories":[{"name":"测试","slug":"测试","permalink":"https://www.sorrytime.cn/categories/测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://www.sorrytime.cn/tags/测试/"}]}]}